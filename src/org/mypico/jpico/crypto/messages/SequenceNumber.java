/*
 * (C) Copyright Cambridge Authentication Ltd, 2017
 *
 * This file is part of jpico.
 *
 * jpico is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * jpico is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with jpico. If not, see
 * <http://www.gnu.org/licenses/>.
 */


package org.mypico.jpico.crypto.messages;

import java.math.BigInteger;
import java.security.SecureRandom;

import com.google.common.base.Objects;

/**
 * SequenceNumber exists to ensure that the mutual authentication between the Pico and the Service
 * is current, it prevents replay attacks.
 * <p>
 * Underneath, it is an incrementing bit string which is sent in the encrypted part of the
 * {@link EncPicoReauthMessage} and {@link EncServiceReauthMessage}, and both sides verify and then
 * respond to the sequence number.
 *
 * @author David Llewellyn-Jones <dl551@cam.ac.uk>
 * @author Graeme Jenkinson <gcj21@cam.ac.uk>
 */
public final class SequenceNumber {

    /**
     * Challenge length in bytes
     */
    private static final int SEQUENCE_NUMBER_LENGTH = 32;

    private final BigInteger sequenceNumber;

    /* ********************** Create a new Challenge ********************** */

    SequenceNumber(final BigInteger sequenceNumber) {
        this.sequenceNumber = sequenceNumber;
    }

    /**
     * Generates a new sequence number, using a SecureRandom.
     *
     * @return The {@code SequenceNumber} object created that encapsulates the generated sequence
     * number.
     */
    public static SequenceNumber getRandomInstance() {
        byte[] sequenceNumberBytes = new byte[SEQUENCE_NUMBER_LENGTH];
        SecureRandom secureRandom = new SecureRandom();
        secureRandom.nextBytes(sequenceNumberBytes);
        // Interpret sequenceNumberBytes as magnitude of the BigInteger,
        // so it is always positive or zero.
        BigInteger sequenceNumber = new BigInteger(1, sequenceNumberBytes);
        return new SequenceNumber(sequenceNumber);
    }

    /* *********************** Respond to a sequence number *********************** */

    /**
     * Returns a new sequence number, which is used both as the response to the previous sequence
     * number from the other side and the next sequence number for the other side to respond to.
     *
     * @return The response to this sequence number.
     */
    public SequenceNumber getResponse() {
        return new SequenceNumber(getIncrementedChallenge());
    }

    /**
     * Check that a response to the current sequence number by the other party is valid.
     *
     * @param cr The response to be tested.
     * @return true if the response was correct, false otherwise/
     */
    public boolean verifyResponse(SequenceNumber cr) {
        return cr.sequenceNumber.equals(getIncrementedChallenge());
    }

    /* *************************** Helper methods *************************** */

    private BigInteger getIncrementedChallenge() {
        BigInteger addedOne = sequenceNumber.add(BigInteger.ONE);
        // Check if we need to wrap back to zero.
        byte[] addedOneBytes = addedOne.toByteArray();
        if (addedOneBytes.length > SEQUENCE_NUMBER_LENGTH && addedOneBytes[0] != 0) {
            // Wrap around internal state to match external output.
            return BigInteger.ZERO;
        } else {
            return addedOne;
        }
    }

    /* ************************ Object Methods ************************ */

    /**
     * Compares to sequence numbers.
     */
    @Override
    public boolean equals(Object o) {
        if (o instanceof SequenceNumber) {
            return sequenceNumber.equals(((SequenceNumber) o).sequenceNumber);
        } else {
            return false;
        }
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(sequenceNumber);
    }

    @Override
    public String toString() {
        return sequenceNumber.toString();
    }

    /* *********************** Serialisation Methods *********************** */

    /**
     * Makes a SequenceNumber object from a byte array, as included in the encrypted byte stream in
     * the {@link PicoReauthMessage} and {@link ServiceReauthMessage}.
     *
     * @param sequenceNumberByteArray numberByteArray The byte array representation of the sequence number, as
     *                                generated by {@link BigInteger#toByteArray()}.
     * @return The SequenceNumber constructed from that byte array.
     */
    public static SequenceNumber fromByteArray(byte[] sequenceNumberByteArray) {
        // Force non-two's complement interpretation of the bits.
        return new SequenceNumber(new BigInteger(1, sequenceNumberByteArray));
    }

    /**
     * Serialise this sequence number into a byte array to be sent as part of the encrypted byte
     * stream in {@link PicoReauthMessage} and {@link ServiceReauthMessage}.
     * <p>
     * The sequence number can be reconstructed by {@link SequenceNumber#fromByteArray(byte[])}.
     *
     * @return The byte array representation of this sequence number.
     */
    public byte[] toByteArray() {
        byte[] bigIntBytes = sequenceNumber.toByteArray();
        byte[] bytes = new byte[SEQUENCE_NUMBER_LENGTH];
        int bytesToCopy = Math.min(bigIntBytes.length, SEQUENCE_NUMBER_LENGTH);
        // Copy bytesToCopy bits from the end of bigIntBytes, and output to
        // the end of bytes.

        // Both are needed as the output from BigInt's toByteArray could be
        // short (i.e. the number is low) or too long (i.e. the number is in
        // the upper half of the representation)
        System.arraycopy(
            bigIntBytes,
            bigIntBytes.length - bytesToCopy,
            bytes,
            SEQUENCE_NUMBER_LENGTH - bytesToCopy,
            bytesToCopy);
        return bytes;
    }
}